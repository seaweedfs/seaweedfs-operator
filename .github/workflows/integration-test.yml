name: Integration Tests

on:
  pull_request:
    types:
      - opened
      - labeled
      - synchronize
    paths:
      - '**/*.go'
      - 'go.mod'
      - 'go.sum'
      - 'Makefile'
      - '.github/workflows/integration-test.yml'
      - 'config/**'
  push:
    branches:
      - main
      - master
    paths:
      - '**/*.go'
      - 'go.mod'
      - 'go.sum'
      - 'Makefile'
      - '.github/workflows/integration-test.yml'
      - 'config/**'

jobs:
  determine-versions:
    runs-on: ubuntu-22.04
    outputs:
      matrix: ${{ steps.versions.outputs.matrix }}
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Determine latest K8s versions
        id: versions
        run: |
          set -euo pipefail
          set -x

          # Try to fetch tags (tags endpoint tends to be smaller and contains semantic tags)
          PER_PAGE=200
          API_URL="https://api.github.com/repos/kubernetes/kubernetes/tags?per_page=${PER_PAGE}"
          VERSIONS_RAW=$(curl -sS --fail "$API_URL" || true)

          if [ -z "${VERSIONS_RAW:-}" ]; then
            echo "Warning: failed to fetch Kubernetes tags; using fallback versions" >&2
            MATRIX='[{"version":"v1.31.0","attribute":"latest"},{"version":"v1.30.0","attribute":"current"},{"version":"v1.29.0","attribute":"previous"}]'
            echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract candidate tag names. Prefer jq; fall back to Python parsing if jq missing.
          if command -v jq >/dev/null 2>&1; then
            # Only accept full semver tags like v1.X.Y (exclude alpha/beta/rc)
            CANDIDATES=$(printf '%s' "$VERSIONS_RAW" | jq -r '.[].name' | grep -E '^v1\.[0-9]+\.[0-9]+$' || true)
          else
            # python fallback also restricts to v1.X.Y
            CANDIDATES=$(printf '%s' "$VERSIONS_RAW" | python3 -c 'import sys,json,re;data=json.load(sys.stdin);out=[item.get("name") for item in data if isinstance(item,dict) and item.get("name") and re.match(r"^v1\.[0-9]+\.[0-9]+$", item.get("name"))]; print("\n".join(out))')
          fi

          # Compute latest patch per minor (e.g., pick v1.34.2 for minor 1.34),
          # then pick the latest 3 minor versions (1.34,1.33,1.32)
          NUM=3
          # LATEST_PER_MINOR: for each minor (1.X) keep the highest patch
          LATEST_PER_MINOR=$(printf '%s' "$CANDIDATES" | sed 's/^v//' | sort -V | awk -F. '{ minor=$1"."$2; versions[minor]=$0 } END { for (m in versions) print versions[m] }')
          # Now sort by semver desc (latest minor first) and pick top NUM
          VERSIONS=$(printf '%s' "$LATEST_PER_MINOR" | sort -V -r | head -n "$NUM" | sed 's/^/v/')

          # Build matrix as array of objects {version, attribute}
          MATRIX='[]'
          ATTRIBUTES=("latest" "current" "previous")

          # read into array preserving newlines (VERSIONS already latest-first)
          mapfile -t arr <<<"${VERSIONS:-}"
          for i in "${!arr[@]}"; do
            v=${arr[i]}
            a=${ATTRIBUTES[i]:-latest}
            MATRIX=$(echo "$MATRIX" | jq --arg v "$v" --arg a "$a" '. += [{"version": $v, "attribute": $a}]')
          done

          # If parsing produced empty matrix, use fallback defaults
          if [ "$(echo "$MATRIX" | jq length)" -eq 0 ]; then
            MATRIX='[{"version":"v1.31.0","attribute":"latest"},{"version":"v1.30.0","attribute":"current"},{"version":"v1.29.0","attribute":"previous"}]'
          fi

          # Compact JSON (no newlines) so it can be safely written to GITHUB_OUTPUT
          MATRIX=$(echo "$MATRIX" | jq -c '.')
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

  integration-test:
    name: Integration Tests on k8s ${{ matrix.k8s.version }}
    needs: determine-versions
    # Pull request has label 'ok-to-test' or the author is a member of the organization, or it's a push to main/master
    if: |
      github.event_name == 'push' ||
      contains(github.event.pull_request.labels.*.name, 'ok-to-test') ||
      contains(fromJSON('["COLLABORATOR", "MEMBER", "OWNER"]'), github.event.pull_request.author_association)

    strategy:
      fail-fast: false
      matrix:
        k8s: ${{ fromJson(needs.determine-versions.outputs.matrix) }}

    runs-on: ubuntu-22.04
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.30.0'

      - name: Run unit tests
        run: make test

      - name: Build manager binary
        run: make build

      - name: Set up Kind cluster
        run: |
          # Use specific Kubernetes version
          K8S_VERSION=${{ matrix.k8s.version }} make kind-prepare
        env:
          KIND_CLUSTER_NAME: seaweedfs-operator-kind-${{ github.run_id }}

      - name: Build and load Docker image
        run: |
          make docker-build
          make kind-load
        env:
          KIND_CLUSTER_NAME: seaweedfs-operator-kind-${{ github.run_id }}
          IMG: ghcr.io/seaweedfs/seaweedfs-operator:test-${{ github.run_id }}

      - name: Deploy operator
        run: |
          make deploy
          # Wait for the operator to be ready
          kubectl wait deployment.apps/seaweedfs-operator-controller-manager \
            --for condition=Available \
            --namespace seaweedfs-operator-system \
            --timeout 300s
        env:
          KIND_CLUSTER_NAME: seaweedfs-operator-kind-${{ github.run_id }}
          IMG: ghcr.io/seaweedfs/seaweedfs-operator:test-${{ github.run_id }}

      - name: Run integration tests
        run: |
          # Run all e2e tests including the new resource integration tests
          go test ./test/e2e/ -v -ginkgo.v -ginkgo.progress -timeout 20m
        env:
          KIND_CLUSTER_NAME: seaweedfs-operator-kind-${{ github.run_id }}

      - name: Collect operator logs on failure
        if: failure()
        run: |
          echo "=== Operator Manager Logs ==="
          kubectl logs -n seaweedfs-operator-system deployment/seaweedfs-operator-controller-manager --tail=100 || true

          echo "=== All Pods in operator namespace ==="
          kubectl get pods -n seaweedfs-operator-system || true

          echo "=== All Pods in test namespace ==="
          kubectl get pods -n test-resources || true

          echo "=== Events ==="
          kubectl get events --all-namespaces --sort-by='.lastTimestamp' --tail=50 || true

          echo "=== StatefulSets ==="
          kubectl get statefulsets --all-namespaces || true

          echo "=== Seaweed Resources ==="
          kubectl get seaweed --all-namespaces -o yaml || true

      - name: Cleanup
        if: always()
        run: |
          # Cleanup the Kind cluster
          make kind-delete || true
        env:
          KIND_CLUSTER_NAME: seaweedfs-operator-kind-${{ github.run_id }}

  resource-validation-test:
    name: Resource Validation Test
    runs-on: ubuntu-22.04
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Run resource filtering unit tests
        run: |
          go test ./internal/controller/ -run TestFilterContainerResources -v

      - name: Validate helper function behavior
        run: |
          echo "Testing that storage resources are properly filtered..."
          go test ./internal/controller/ -run TestFilterContainerResources -v

          echo "Verifying filter function exists and compiles..."
          go build -o /dev/null ./internal/controller/

  build-check:
    name: Build Check
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Check if code compiles
        run: |
          go mod tidy
          make build

      - name: Check if Docker image builds
        run: |
          make docker-build
        env:
          IMG: test-image:latest
